
from mlagents_envs.environment import UnityEnvironment
from gym_unity.envs import UnityToGymWrapper
from mlagents_envs.side_channel.engine_configuration_channel import EngineConfigurationChannel

import os
import sys
import numpy as np
from numpy import save
from numpy import load
import pickle 
from PIL import Image as IMG
import time
import math
import cv2

def process_frame(frame):
    """Preprocess a 70x210x3 frame to 35x105x1 grayscale
    
    Arguments: 
        frame: The frame to process. Must have values ranging from 0-1
    Returns: 
        The processed frame
    """
    frame = frame[::2,::2]  # Downsample by 2 in every dimension   
    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    
    return frame

def colorScale_ZA( value, val_min, val_max, zero_level=120, scalar_only=False ): # ZA: zero align (preset zero_level in [0,1024])
	# checks
	if val_max <= val_min: return (255,0,255,255) if scalar_only==False else -1.0	# ERR
	if value   >  val_max: return (128,0,0,255)   if scalar_only==False else 1024	# pos cutoff
	if value   <  val_min: return (0,0,128,255)   if scalar_only==False else  0.0	# neg cutoff
	# setup
	pos_scale    = 1024.0-zero_level
	scale_factor = pos_scale/val_max
	scale_value  = zero_level + (value*scale_factor)
	if scalar_only == True: return int(scale_value if scale_value >= 0 else 0)
	# cutoff smaller values
	if scale_value < 0: return (0,0,0,255)
	# scale value to RGB color
	rgb = np.array([0,0,0])
	if( scale_value < 128 ):
		rgb[2] = 128 + scale_value
	elif( scale_value < 384 ):
		rgb[1] = scale_value-128
		rgb[2] = 255
	elif( scale_value < 640.0 ):
		rgb[0] = scale_value-384
		rgb[1] = 255
		rgb[2] = 255 - (scale_value-384)
	elif( scale_value < 896 ):
		rgb[0] = 255
		rgb[1] = 255 - (scale_value-640)
	elif( scale_value <= 1024 ):
		rgb[0] = 255 - (scale_value-896)
	else:
		return (255,255,255,255) ### ERR
	# return RGBA color tuble
	return (rgb[0],rgb[1],rgb[2],255)

# This initializes the environment to interact with
unity_env = UnityEnvironment("./square_env/SquareRoom.exe")
env = UnityToGymWrapper(unity_env, allow_multiple_obs=True)

# Get trained SFA network from .tsn file ---------------------------------------
tsn_file = sys.argv[1]

for f in os.listdir(): 
   if '.tsn' in f: tsn_file = f
if tsn_file == '-':
	print('Error! No .tsn file was found in current folder.')
	print('This file is generated by train.py after training a network.')
	sys.exit()

try:
	print('Loading .tsn file \'%s\'.' % tsn_file)
	tsn_file = open(tsn_file, 'rb' )
except:
	print('Error opening SFA network file!')
	sys.exit()

sfa_network = pickle.load( tsn_file )


# Create folders in case they don't exists yet ----------------------------------

for folder in ['sfa_plots', 'network_values']:
    fail = False
    if( os.path.isdir('./experiment/'+folder) == False ):
        try:	os.mkdir('./experiment/'+folder)
        except:	fail = True

    # if( os.path.isdir('./experiment/'+folder+'/local') == False ):
    #     try:	os.mkdir('./experiment/'+folder+'/local')
    #     except:	fail = True

    # if( os.path.isdir('./experiment/'+folder+'/average') == False ):
    #     try:	os.mkdir('./experiment/'+folder+'/average')
    #     except:	fail = True

if fail:
	print('Error! Required folders could not be created.')
	sys.exit()


sample_dir = ['N','W','S','E']
ctrl_sample_data = []

limits = [-7, -7, 7, 7]
sample_period = 1
num_signals = 5

world_size_x = limits[2] - limits[0]
world_size_y = limits[3] - limits[1]

world_sample_size_x = int( world_size_x / sample_period ) + 1
world_sample_size_y = int( world_size_y / sample_period ) + 1

print('Sampling %d run(s); extracting the %d slowest signals.' % (len(sample_dir), num_signals))
print('Using sampling period %d (%d position checks per sampling run)' % ( sample_period, world_sample_size_x*world_sample_size_y ))

sample_img  = IMG.new( 'RGBA', (world_sample_size_x,world_sample_size_y) )
sample_data = sample_img.load()

angle = 0

# Loop for every different direction the robot at which the robot will sample
for r in range(0, len(sample_dir)):
    print('Looping with direction ' + sample_dir[r][0])
    # sampling data for next direction
    sample_data_raw = np.zeros( (num_signals, world_sample_size_x, world_sample_size_y) )
    ctrl_sample_data.append( sample_data_raw )

    # Reset agent to origin and send to left lower corner
    env.reset()    
    env.step([-7,-7,angle])
    
	# loop through positions
    ping  = time.time()
    cnt   = 0.0
    first_cycle = True
    old_pos_y = -7
    debug_pos = np.zeros((1,2))
    
    # Loop to make the robot move between grid points, obtain images and feed them to the network
    for pos_y in range(limits[1],limits[3]+1,sample_period):
        for pos_x in range(limits[0],limits[2]+1,sample_period):
            
            change_lane = (pos_y - old_pos_y) != 0 
            
            # Move agent and extract image
            if (pos_x == -7) and first_cycle:
                obs = env.step([0,0,0])
                first_cycle = False
            elif change_lane:
                obs = env.step([-14,1,0])                
            else:
                obs = env.step([1,0,0])
            
            #For debuggin only
            new_pos = obs[0][2][1:3].reshape(1,2)
            debug_pos = np.append(debug_pos, new_pos, axis= 0)
            
            #Obtain fram and process it 
            frame_data = process_frame(obs[0][0])*255
            frame_data = np.uint8(np.round(frame_data))
            data = frame_data.flatten().reshape( (1, 105*35) )
            
            # Get network value
            network_result = sfa_network.execute( data )
            for k in range(0, num_signals):
                sample_data_raw[k, (pos_x-limits[0])//sample_period, (pos_y-limits[1])//sample_period] = network_result[0,k]

			# update progress bar
            cnt += 1
            old_pos_y = pos_y
            done = int( cnt/(world_sample_size_x*world_sample_size_y)*50.0 )
            sys.stdout.write( '\r' + '[SAMPLING][' + '='*done + '-'*(50-done) + ']~[' + '%d/%.2f' % (cnt,cnt/(world_sample_size_x*world_sample_size_y)*100.0) + '%]' )
            sys.stdout.flush()
    
    
    debug_pos = np.round(debug_pos,2)
    debug_pos = np.delete(debug_pos, 0, axis=0)
    
    save('./experiment/firing_map',sample_data_raw)
    save('./experiment/debug_pos',debug_pos)
    print('~[%dmin/%dsec]' % ((time.time()-ping)//60, (time.time()-ping)%60.0))

    # Loop through each slow feature to find local min/max, rescale data and make the plots
    for k in range(0, num_signals):
        print('Plotting slow feature ' + str(k+1))
        
        local_max = np.finfo('f').min  # Pos. Inifity
        local_min = np.finfo('f').max  # Neg. Infinity
        
     	# find data range 
        for y in range(0,world_sample_size_y):
            for x in range(0,world_sample_size_x):
                if sample_data_raw[k,x,y] > local_max:
                    local_max = sample_data_raw[k,x,y]
                if sample_data_raw[k,x,y] < local_min:
                    local_min = sample_data_raw[k,x,y]
    
        # polarize heuristic: largest value assumed to be positive
        sample_sign = 1
        if abs(local_min)>abs(local_max):
            tmp         = local_min
            local_min   = -local_max
            local_max   = -tmp
            sample_sign = -1
    
        # scale local response to color range
        sample_data_scaled = np.zeros([world_sample_size_x,world_sample_size_y])
        for y in range(0,world_sample_size_y):
            for x in range(0,world_sample_size_x):
                sample_data[x,y]        = colorScale_ZA( sample_sign*sample_data_raw[k,x,y], local_min, local_max )
                sample_data_scaled[x,y] = colorScale_ZA( sample_sign*sample_data_raw[k,x,y], local_min, local_max, scalar_only=True )      

        # write plots
        filename = 'slow_feature_' + str(k+1) + '_' + sample_dir[r] + '['+str(np.round(local_min,3))+';'+str(np.round(local_max,3))+']' + '.png'

        # Resize images 
        n = 20  # Resize factor
        basewidth = int(sample_img.size[0])
        hsize = int(sample_img.size[1])
        img = sample_img.resize((basewidth*n,hsize*n), IMG.ANTIALIAS)
        img.transpose(IMG.FLIP_TOP_BOTTOM).save( './experiment/sfa_plots/' + filename  )
        
        # write sample values
        filename = 'slow_feature_' + str(k+1) + '_' + sample_dir[r] + '.txt'
        np.save( './experiment/network_values/'+filename, np.round(sample_data_raw[k]*sample_sign,2) )

    angle += -0.5*np.pi
    
    print('Firingmaps saved on directory \'./experiments/sfa_plots/\'')
    
# 	# average sampled activity over directions
# 	print('Averaging samples..')
# 	for k in range(ctrl.cfg.num_signals):

# 		# average activity of signal k at all sampled positions
# 		avg = numpy.zeros( (world_sample_size_x,world_sample_size_y) )
# 		for d, dir in enumerate(ctrl.cfg.sample_dir):
# 			avg += ctrl.state.sample_data[d][k]
# 		avg /= len(ctrl.cfg.sample_dir)

# 		# local scale and polarization
# 		sample_sign = 1
# 		local_max = numpy.nanmax( avg.flatten() )
# 		local_min = numpy.nanmin( avg.flatten() )
# 		if abs(local_min) > abs(local_max):
# 			tmp = local_min
# 			local_min   = -local_max	
# 			local_max   = -tmp
# 			sample_sign = -1
# 	
# 		# average plot
# 		sample_data_scaled = numpy.zeros([world_sample_size_x,world_sample_size_y])
# 		for y in range(0,world_sample_size_y):
# 			for x in range(0,world_sample_size_x):
# 				if numpy.isnan( avg[x,y] ):
# 					sample_data[x,y]        = (0,0,0)
# 					sample_data_scaled[x,y] = 0
# 				else:
# 					sample_data[x,y]        = colorScale_ZA( sample_sign*avg[x,y], local_min, local_max )
# 					sample_data_scaled[x,y] = colorScale_ZA( sample_sign*avg[x,y], local_min, local_max, scalar_only=True )
# 		
# 		# write plots
# 		if ctrl.cfg.verbose:
# 			filename = ctrl.cfg.file_prefix + 'avg_sample_' + str(k+1) + '['+str(local_min)+';'+str(local_max)+']' + '.png'
# 		else:
# 			filename = ctrl.cfg.file_prefix + 'avg_sample_' + str(k+1) + '.png'
# 		sample_img.transpose(IMG.FLIP_TOP_BOTTOM).save( './current_experiment/sampling_plots/average/' + filename  )

# 		# write sample values
# 		filename = ctrl.cfg.file_prefix + 'avg_sample_' + str(k+1) + '.png'
# 		numpy.savetxt( './current_experiment/sampling_values_raw/average/'+filename, avg*sample_sign )
# 		numpy.savetxt( './current_experiment/sampling_values/average/'+filename,     sample_data_scaled )

# 	print('done.')

